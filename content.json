{"meta":{"title":"Coding Life.log","subtitle":">_","description":"","author":"antisamael","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"学渣也来刷leetcode（一）","slug":"学渣也来刷leetcode（一）","date":"2020-05-22T16:18:07.000Z","updated":"2020-05-22T18:10:22.179Z","comments":true,"path":"2020/05/23/学渣也来刷leetcode（一）/","link":"","permalink":"http://yoursite.com/2020/05/23/%E5%AD%A6%E6%B8%A3%E4%B9%9F%E6%9D%A5%E5%88%B7leetcode%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"算法还是蛮有趣的，虽然已经是个已经快要被干掉的大龄开发（转维护）了，趁着这段被放置的一点都不忙的时候，给自己找点事情做做。作为一个全方面都是弱鸡，特别数学更是绝望的学渣，也来刷刷 leetcode 了。 因为对自己还是有点自知之明的，所以从 Array 的 Easy 开始刷起。 首先是最简单的第一题，1.Two-Sum就是求数组里面的元素如果相加等于9，返回数组的下标，而且限定了会出一个结果。看题目真的是好简单呢，凭直觉写下了下面的代码： class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;int&gt; result(2); for (int i = 0; i &lt; nums.size(); i++) { int a = nums[i]; for (int j = i + 1; j &lt; nums.size(); j++) { int b = nums[j]; if ((a + b) == target) { result = {i, j}; return result; } } } return result; } }; 提交，过了，后来没有然后了，直到看到了1010. Pairs of Songs With Total Durations Divisible by 60这题……这题翻译过来大致意思就是计算出将数组里面的一对数字相加后如果能被60整除的这些对的数量。和 Two Sum 差不多，一眼看上去很简单，于是写了，写法和 Two Sum 差不多，两个 for 暴力怼上去算。提交，失败，因为超时了…… 这个时候回头看 Two Sum，才发现大O复杂度为 O(n^2^)，确实是个十分费时的算法，Two Sum 能过也只是运气好限定了只有一个结果而已吧。然后看看发布后的细节： Runtime: 656 ms, faster than 14.84% of C++ online submissions for Two Sum. 确实是很慢呢…… 先弄到复杂度 O(n) 把！用空间换时间，把索引存到 map 里面去然后直接去找，于是改写一下…… class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;nums, int target) { vector&lt;int&gt; result; map&lt;int, int&gt; val_index; for (size_t i = 0; i &lt; nums.size(); i++) { val_index[nums[i]] = i; } map&lt;int, int&gt;::iterator it; for (size_t i = 0; i &lt; nums.size(); i++) { int other_num = target - nums[i]; it = val_index.find(other_num); if ((it != val_index.end()) &amp;&amp; (it-&gt;second != i)) { result.push_back(i); result.push_back(it-&gt;second); return result; } } return result; } }; 这应该是最普通的思路了，虽然时间快了不少，空间真是占了好大了。而且这个算法不是最快的……","categories":[],"tags":[{"name":"算法, C++","slug":"算法-C","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95-C/"}]},{"title":"配置好用又个性的 Windows Terminal","slug":"配置好用又个性的-Windows-Terminal","date":"2020-05-20T15:58:55.000Z","updated":"2020-05-20T17:49:42.287Z","comments":true,"path":"2020/05/20/配置好用又个性的-Windows-Terminal/","link":"","permalink":"http://yoursite.com/2020/05/20/%E9%85%8D%E7%BD%AE%E5%A5%BD%E7%94%A8%E5%8F%88%E4%B8%AA%E6%80%A7%E7%9A%84-Windows-Terminal/","excerpt":"","text":"Windows Terminal 1.0 发布了，用了一段时间的预览版，还不错，记录和分享一下它的配置了。 安装WT 项目的源码目前在 GitHub 上，地址是：https://github.com/microsoft/terminal官方推荐的安装方式是从 Microsoft Store 上安装，也可以使用 Chocolatey 安装，如果想要在不支持外网的工作PC使用，因为目前没有安装包，只能下载源码编译了，详细方法先留个坑，后面再发文介绍。 安装好以后，第一印象是：终于官方支持多标签页的终端了！然后还支持不同的入口，除了默认的 Cmd 和 Powershell，通过修改配置，还支持快速进入 WSL 和 VPS……支持设置背景和背景透明度，可以大大提升 WT 的颜值，我已经把我的 MobaXterm 给删了。 配置 / 个性化WT 的配置文件分为 4 个部门，一个是全局配置，另外 3 个分别配置 WT 的入口、主题、快捷键；下面各个介绍一下： 全局配置中常用的配置项大致就这么几个： defaultProfile: 打开 WT 后默认的入口 guid requestedTheme: 适配亮/暗主题，我是设置为 “system” 跟随系统了 copyOnSelect: 选中文字后自动复制，建议设置为 true 入口的配置： 这里分享一下我的 Powershell 的配置 { // Make changes here to the powershell.exe profile &quot;guid&quot;: &quot;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}&quot;, &quot;name&quot;: &quot;Windows PowerShell&quot;, &quot;commandline&quot;: &quot;powershell.exe&quot;, &quot;hidden&quot;: false, &quot;fontFace&quot;: &quot;Sarasa Mono T SC&quot;, &quot;fontSize&quot;:11, &quot;backgroundImage&quot;:&quot;D:/OneDrive/Pictures/Wallpaper/winx/Untitled Goose Wallpaper.png&quot;, &quot;backgroundImageStretchMode&quot;: &quot;uniformToFill&quot;, &quot;backgroundImageOpacity&quot;: 0.6, &quot;colorScheme&quot;:&quot;One Half Dark&quot; }, 还有 VPS 的： { &quot;guid&quot;: &quot;{a9fc51e9-101f-4548-aad9-3d9e7a934801}&quot;, &quot;hidden&quot;: false, &quot;name&quot;: &quot;Bandwagon VPS&quot;, &quot;commandline&quot;: &quot;powershell.exe ssh -p xxxxx root@xxx.xxx.xxx.xxx&quot;, &quot;fontFace&quot;: &quot;Sarasa Mono T SC&quot;, &quot;fontSize&quot;:11, &quot;useAcrylic&quot;:true, &quot;acrylicOpacity&quot;:1, &quot;icon&quot;:&quot;D:\\\\OneDrive\\\\Pictures\\\\Icon\\\\icons8-centos-48.png&quot;, &quot;colorScheme&quot;:&quot;Gruvbox Dark&quot; } 唯一的GUID可以通过网站在线生成 配色方案： iTerm2 的代码仓中有为 WT 配置好的配色方案，我们将方案复制到我们的配置文件中即可。 增强pshazz 我的 WT 配置","categories":[],"tags":[{"name":"Tool","slug":"Tool","permalink":"http://yoursite.com/tags/Tool/"}]},{"title":"使用Pandas处理Excel操作总结","slug":"使用Pandas处理Excel操作总结","date":"2020-05-16T14:47:35.000Z","updated":"2020-05-20T16:14:10.431Z","comments":true,"path":"2020/05/16/使用Pandas处理Excel操作总结/","link":"","permalink":"http://yoursite.com/2020/05/16/%E4%BD%BF%E7%94%A8Pandas%E5%A4%84%E7%90%86Excel%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/","excerpt":"","text":"去年年底从开发岗转到维护岗后，工作中需要处理大量的 Excel 表格，由于之前做开发的时候很少接触 Excel，对于它的认知也就是会使用 SUM 这些简单的公式，VBA 更是没有接触过了，面对大量的 Excel 文档和他们动辄几万行的数据，人工处理实在是太浪费时间了，还好之前自学过一点 Python，于是便开始了自我救赎之旅。 研究了几个可以用于处理 Excel 的模块之后，我最终选择了 Pandas 和 openpyxl Pandas 主要用来处理数据，openpyxl 用于处理样式和保存文档。 这里只记录一下工作过程中经常用到的几个方法。 读取 Excel 文件读取 Excel 文件的方法是 read_excel() import pandas as pd fd = pd.read_excel(&quot;Workbook.xlsx&quot;, &quot;SheetX&quot;) print(fd) 第一个参数填写 Excel 文件的路径，第二个参数填写需要打开的标签页；第二个参数如果不填，则默认打开第一个标签页。 保存 Excel 文件保存 Excel 文件的方法方式 to_excel() fd.to_excel(&quot;Workbook_copy.xlsx&quot;) 需要注意的是，保存的excel是不带样式的，所以我一般只用它来做测试查看结果是否符合预期，要输出可以交付的文档的时候，一般使用都是先使用 pandas 得到想要的数据，然后使用 openpyxl 保存。 另外，默认的保存方式得到的 Excel 表格是带有 index （可以理解为原始数据的行号，不过是以 0 开头）和 header （列标），如果不需要它，那么再后面加上参数 index=None 和 header=None 即可。 fd.to_excel(&quot;Workbook_copy.xlsx, index=None, header=None&quot;) 选取单元格内容使用 loc 和 iloc 方法， 他们之间的区别是 loc 是基于行标签和列标签， iloc 基于行索引和列索引。 读取一行 fd.loc(1, :) 读取一列 fd[&#39;列标签1&#39;] # 通常的做法 fd.loc(:, [&#39;列标签1&#39;]) # 还可以这么做 读取一行一列 fd.loc[3,[&#39;列标签1&#39;]] # or fd.iloc[3, 0] 读取多行多列 fd.loc[[1, 3, 5], [&#39;列标签1&#39;, &#39;列标签2&#39;]] # or fd.iloc[[1, 3, 5], [0, 1]] 读取某列所有元素vals = fd.loc(&#39;列标签&#39;).to_list() 筛选比如我们的表格中有一列的索引名称为“是否安装”，想选取值为 N 的数据： data_y = data[data[&#39;是否安装&#39;] == &#39;N&#39;] 使用 &amp; 和 | 可以使用更多的筛选条件，比如： data_y = data[(data[&#39;是否安装&#39;] == &#39;Y&#39;) &amp; (data[&#39;用途&#39;] == &#39;效率&#39;)] 对于更复杂的筛选条件，使用 apply ，先用简单的例子来说明一下，比如还是上文的选取索引值名称为“是否安装”里面 N 的数据，如果要用 apply 方法实现的话： def IsInstalled(val): return val == &#39;N data_y = data[data[&#39;是否安装&#39;].apply(IsInstalled)] apply 可以带有参数，更为灵活 def IsInstalledArgs(val, is_install): return val == is_install data_y = data[data[&#39;是否安装&#39;].apply(IsInstalledArgs, args=(&#39;N&#39;,))] 统计df.shape # 返回数据的行列 df.count # 返回每一列中非空值的个数 len(df[&#39;Column&#39;].index.values) # 数据的条数 修改df[3, &#39;列标签&#39;] = &#39;一个新值&#39; Pandas 还有很多方法，但以上方法对于我目前日常处理 Excel 数据的操作是够用的了，后面遇到了再补充吧。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-03-20T17:19:56.000Z","updated":"2020-03-23T16:16:01.334Z","comments":true,"path":"2020/03/21/hello-world/","link":"","permalink":"http://yoursite.com/2020/03/21/hello-world/","excerpt":"","text":"你好，这是我的第一篇个人博客，主要记录一些软件工程，编码的心得，还有相关工具使用方法。 #include &lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; &quot;Hello,world!&quot; &lt;&lt; endl; return 0; }","categories":[],"tags":[{"name":"misc","slug":"misc","permalink":"http://yoursite.com/tags/misc/"}]}],"categories":[],"tags":[{"name":"算法, C++","slug":"算法-C","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95-C/"},{"name":"Tool","slug":"Tool","permalink":"http://yoursite.com/tags/Tool/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"misc","slug":"misc","permalink":"http://yoursite.com/tags/misc/"}]}
{"meta":{"title":"cat coding_life.log","subtitle":">_","description":"","author":"antisamael","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"简历模板","slug":"简历模板","date":"2020-06-22T18:19:44.000Z","updated":"2020-06-22T18:41:11.031Z","comments":true,"path":"2020/06/23/简历模板/","link":"","permalink":"http://yoursite.com/2020/06/23/%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"技术能力我熟悉C语言，能熟练使用指针； 我熟悉C++语言很多特性和库，如 OO，泛型，和 C++ 的常用库，如 STL，boost 等，能够熟练定位出各种C++问题； 我熟悉 现代C++（C11/C14/C17…） 特性，喜欢使用现代C++方式编写新代码。 我会用正则表达式 早年我在Windows平台下使用Virtual Studio进行C++开发，主要用到MFC编程，我熟悉VS工具下的C++代码编写和调试；后面主要从事Linux嵌入式开发，使用SourceInsight和VSCode，配合使用gdb，vim，top等GNU工具来调试代码、定位bug和分析性能问题，我了解 Linux Shell 基本用法，可以熟练使用 awk，sed 等常用命令或工具； 除了本职工作，我还喜欢接触新技术，对前沿热门技术有强烈的求知欲，比如：我会使用 Python，配合 numpy，pandas，openpyxl 等模块，帮我分析大量数据或实现一些自动化操作，提高我的本职工作效率。 我可以写出高质量的代码，因为:我熟悉大部分算法，可以写出高效率的代码我熟悉大多数设计模式，可以写出易维护，易扩展的代码；我有良好的编程习惯，可以写出干净，可读性高的代码；我熟悉重构，维护代码的稳定健康；我熟练使用GIT并有良好的上库习惯，能做到代码层面从分溯源 我喜欢总结分享经验，熟练使用 Markdown 和 UML 流程图等工具，发布给大家学习交流。我为人谨慎细心，倾向于先对齐需求并保证代码bugfree的基础上实现更快交付，可能我的交付不是最快的，但问题是最少的，返工率定，修改也是最好改正的。我有强烈的责任心，事情没有做到我满意的程度我不好意思回家。 小目标我还不熟悉多线程编程和网络编程，进程间通信业不是太了解，比如锁，信号量，中断啥的，多线程我理解概念，但实际上没怎么使用过。进程间通信我可能在我不知道的状态下已经用过了。我还不会用Makefile构建项目不会部署CI环境，如代码静态动态检查，鹰眼等不会写单元测试，即测试驱动开发不会用Wireshark等抓包工具分析网络报文不熟悉Linux下面的环境变量，常用信号量我还不晓得Docker是什么鬼，大数据和人工智能也不甚了解。我还初步了解了Go和Rust；我还要学习一下前端工具，JavaScript和Typescript等，熟悉一些前端框架，Vue和Nodejs等，支持我实现一些自开发工具的前端显示；","categories":[],"tags":[{"name":"Misc","slug":"Misc","permalink":"http://yoursite.com/tags/Misc/"}]},{"title":"Regex 速查表和常用技巧总结","slug":"Regex速查表和常用技巧总结","date":"2020-06-22T16:17:09.000Z","updated":"2020-06-22T18:06:52.791Z","comments":true,"path":"2020/06/23/Regex速查表和常用技巧总结/","link":"","permalink":"http://yoursite.com/2020/06/23/Regex%E9%80%9F%E6%9F%A5%E8%A1%A8%E5%92%8C%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/","excerpt":"","text":"元字符 代码 说明 . 除换行符外任意一个字符 \\w 匹配字母或数字或下划线或汉字 \\s 匹配任意的空白符 \\d 匹配数字 \\b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 限定符（指定重复）限定符是一种特殊的元字符，用于指定它前面的表达式的重复次数 代码/语法 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 字符类（字符集合）使用方括号 [] 框起来可以匹配字符的集合，比如： [aeiou] 匹配任何一个元音字母 还有一些常用的有： [a-b][1-9][0-26-9] 匹配 02，69 中的任意数字 分枝条件（或）使用 | 分隔不同的表达式，满足任意一种规则都可以认为匹配 反义将元字符大写或者前面加上^来表示反义： 代码/语法 说明 \\W 匹配任意不是字母，数字，下划线，汉字的字符 \\S 匹配任意不是空白符的字符 \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 例子：&lt;a[^&gt;]+&gt; 匹配用尖括号括起来的以a开头的字符串。[^1-3] 不匹配 1~3 的数字 贪婪和懒惰当表达式中带有指定重复的限定符时，如：a\\w+b ，正则表达式默认为贪婪匹配，即匹配尽可能多的字符如 aabababab 使用上面的表达式会匹配整个字符串。如果我们只需要匹配第一次出现的符合表达式的字符串，则可以使用懒惰匹配使用懒惰匹配的方法是，在限定符后面加上问号 ?，如：a\\w+?b，则返回的是 aab 和 ab 分组/子表达式用小括号来指定子表达式(也叫做分组)，可以用来重复多个字符比如 IP 的简单例子（这个表达式不准确，可能匹配到非法的 IP）： (\\d{1,3}\\.){3}\\d{1,3} 后向引用指定子表达式（分组）后，每个分组为默认分配一个组号，分组0 为整个正则表达式，其他则以左括号为标志，从1开始为分组编号然后使用 \\分组号 就可以引用那个分组所捕获到的字符串了，举个例子： ^My name is (\\w+); Hello, \\1$ 匹配：My name is Aki; Hello, Aki （Aki 可以更换为任意单词） 常用的分组语法有： 分类 代码/语法 说明 捕获 (exp) 匹配exp,并捕获文本到自动命名的组里 (?exp) 匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp) (?:exp) 匹配exp,不捕获匹配的文本，也不给此分组分配组号 零宽断言 (?=exp) 匹配exp前面的位置（零宽度正预测先行断言） (?&lt;=exp) 匹配exp后面的位置 （零宽度正回顾后发断言） (?!exp) 匹配后面跟的不是exp的位置 （零宽度负预测先行断言） (?&lt;!exp) 匹配前面不是exp的位置 （零宽度负回顾后发断言） 注释 (?#comment) 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 零宽断言未完待续…","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Regex","slug":"Regex","permalink":"http://yoursite.com/tags/Regex/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"学渣也来刷leetcode（一）","slug":"学渣也来刷leetcode（一）","date":"2020-05-22T16:18:07.000Z","updated":"2020-06-20T08:59:56.325Z","comments":true,"path":"2020/05/23/学渣也来刷leetcode（一）/","link":"","permalink":"http://yoursite.com/2020/05/23/%E5%AD%A6%E6%B8%A3%E4%B9%9F%E6%9D%A5%E5%88%B7leetcode%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"算法还是蛮有趣的，虽然已经是个已经快要被干掉的大龄开发（转维护）了，趁着这段被放置的一点都不忙的时候，给自己找点事情做做。作为一个全方面都是弱鸡，特别数学更是绝望的学渣，也来刷刷 leetcode 了。 因为对自己还是有点自知之明的，所以从 Array 的 Easy 开始刷起。 首先是最简单的第一题，1.Two-Sum就是求数组里面的元素如果相加等于9，返回数组的下标，而且限定了会出一个结果。看题目真的是好简单呢，凭直觉写下了下面的代码： class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;int&gt; result(2); for (int i = 0; i &lt; nums.size(); i++) { int a = nums[i]; for (int j = i + 1; j &lt; nums.size(); j++) { int b = nums[j]; if ((a + b) == target) { result = {i, j}; return result; } } } return result; } }; 提交，过了，后来没有然后了，直到看到了1010. Pairs of Songs With Total Durations Divisible by 60这题……这题翻译过来大致意思就是计算出将数组里面的一对数字相加后如果能被60整除的这些对的数量。和 Two Sum 差不多，一眼看上去很简单，于是写了，写法和 Two Sum 差不多，两个 for 暴力怼上去算。提交，失败，因为超时了…… 这个时候回头看 Two Sum，才发现大O复杂度为 O(n^2^)，确实是个十分费时的算法，Two Sum 能过也只是运气好限定了只有一个结果而已吧。然后看看发布后的细节： Runtime: 656 ms, faster than 14.84% of C++ online submissions for Two Sum. 确实是很慢呢…… 先弄到复杂度 O(n) 把！用空间换时间，把索引存到 map 里面去然后直接去找，于是改写一下…… class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;nums, int target) { vector&lt;int&gt; result; map&lt;int, int&gt; val_index; for (size_t i = 0; i &lt; nums.size(); i++) { val_index[nums[i]] = i; } map&lt;int, int&gt;::iterator it; for (size_t i = 0; i &lt; nums.size(); i++) { int other_num = target - nums[i]; it = val_index.find(other_num); if ((it != val_index.end()) &amp;&amp; (it-&gt;second != i)) { result.push_back(i); result.push_back(it-&gt;second); return result; } } return result; } }; 这应该是最普通的思路了，虽然时间快了不少，空间真是占了好大了。而且这个算法不是最快的……","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"配置好用又个性的 Windows Terminal","slug":"配置好用又个性的-Windows-Terminal","date":"2020-05-20T15:58:55.000Z","updated":"2020-05-22T19:03:44.486Z","comments":true,"path":"2020/05/20/配置好用又个性的-Windows-Terminal/","link":"","permalink":"http://yoursite.com/2020/05/20/%E9%85%8D%E7%BD%AE%E5%A5%BD%E7%94%A8%E5%8F%88%E4%B8%AA%E6%80%A7%E7%9A%84-Windows-Terminal/","excerpt":"","text":"Windows Terminal 1.0 发布了，用了一段时间的预览版，还不错，记录和分享一下它的配置了。 安装WT 项目的源码目前在 GitHub 上，地址是：https://github.com/microsoft/terminal官方推荐的安装方式是从 Microsoft Store 上安装，也可以使用 Chocolatey 安装，如果想要在不支持外网的工作PC使用，因为目前没有安装包，只能下载源码编译了，详细方法先留个坑，后面再发文介绍。 安装好以后，第一印象是：终于官方支持多标签页的终端了！然后还支持不同的入口，除了默认的 Cmd 和 Powershell，通过修改配置，还支持快速进入 WSL 和 VPS……支持设置背景和背景透明度，可以大大提升 WT 的颜值，作为非运维人员也不需要太多功能，所以我已经把 MobaXterm 和 XShell 给丢冷板凳了。 配置 / 个性化按 Ctrl + , 打开WT的配置文件，WT 的配置文件是由json编写的，分为 4 个分，一个是全局配置，另外 3 个分别配置 WT 的入口、主题、快捷键；下面各个介绍一下： 全局配置中常用的配置项大致就这么几个： defaultProfile: 打开 WT 后默认的入口 guid requestedTheme: 适配亮/暗主题，我是设置为 “system” 跟随系统了 copyOnSelect: 选中文字后自动复制，建议设置为 true 入口的配置： 这里分享一下我的 Powershell 的配置 { // Make changes here to the powershell.exe profile &quot;guid&quot;: &quot;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}&quot;, &quot;name&quot;: &quot;Windows PowerShell&quot;, &quot;commandline&quot;: &quot;powershell.exe&quot;, &quot;hidden&quot;: false, &quot;fontFace&quot;: &quot;Sarasa Mono T SC&quot;, &quot;fontSize&quot;:11, &quot;backgroundImage&quot;:&quot;D:/OneDrive/Pictures/Wallpaper/winx/Untitled Goose Wallpaper.png&quot;, &quot;backgroundImageStretchMode&quot;: &quot;uniformToFill&quot;, &quot;backgroundImageOpacity&quot;: 0.6, &quot;colorScheme&quot;:&quot;One Half Dark&quot; }, 还有 VPS 的： { &quot;guid&quot;: &quot;{a9fc51e9-101f-4548-aad9-3d9e7a934801}&quot;, &quot;hidden&quot;: false, &quot;name&quot;: &quot;Bandwagon VPS&quot;, &quot;commandline&quot;: &quot;powershell.exe ssh -p xxxxx root@xxx.xxx.xxx.xxx&quot;, &quot;fontFace&quot;: &quot;Sarasa Mono T SC&quot;, &quot;fontSize&quot;:11, &quot;useAcrylic&quot;:true, &quot;acrylicOpacity&quot;:1, &quot;icon&quot;:&quot;D:\\\\OneDrive\\\\Pictures\\\\Icon\\\\icons8-centos-48.png&quot;, &quot;colorScheme&quot;:&quot;Gruvbox Dark&quot; } 唯一的GUID可以通过网站在线生成 配色方案： iTerm2 的代码仓中有为 WT 配置好的配色方案，我们将方案复制到我们的配置文件中即可。 增强pshazz 我的 WT 配置","categories":[],"tags":[{"name":"Tool","slug":"Tool","permalink":"http://yoursite.com/tags/Tool/"}]},{"title":"使用Pandas处理Excel操作总结","slug":"使用Pandas处理Excel操作总结","date":"2020-05-16T14:47:35.000Z","updated":"2020-06-22T15:42:24.706Z","comments":true,"path":"2020/05/16/使用Pandas处理Excel操作总结/","link":"","permalink":"http://yoursite.com/2020/05/16/%E4%BD%BF%E7%94%A8Pandas%E5%A4%84%E7%90%86Excel%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/","excerpt":"","text":"去年年底从开发岗转到维护岗后，工作中需要处理大量的 Excel 表格，由于之前做开发的时候很少接触 Excel，对于它的认知也就是会使用 SUM 这些简单的公式，VBA 更是没有接触过了，面对大量的 Excel 文档和他们动辄几万行的数据，人工处理实在是太浪费时间了，还好之前自学过一点 Python，于是便开始了自我救赎之旅。 研究了 Python 几个可以用于处理 Excel 的模块之后，我最终选择了 Pandas 和 openpyxl Pandas 主要用来处理数据，openpyxl 用于处理样式和保存文档。 这里只记录一下工作过程中经常用到的几个方法。 读取 Excel 文件读取 Excel 文件的方法是 read_excel() import pandas as pd fd = pd.read_excel(&#39;Workbook.xlsx&#39;) print(fd) 第一个参数填写 Excel 文件的路径，第二个参数填写需要打开的标签页；第二个参数如果不填，则默认打开第一个标签页；下面的脚本是读取 Sheet2 标签页。 fd = pd.read_excel(&#39;Workbook.xlsx&#39;, &#39;Sheet2&#39;) 保存 Excel 文件保存 Excel 文件的方法方式 to_excel() fd.to_excel(&quot;Workbook_copy.xlsx&quot;) 需要注意的是，保存的excel是不带样式的，所以我一般只用它来做测试查看结果是否符合预期，要输出可以交付的文档的时候，一般使用都是先使用 pandas 得到想要的数据，然后使用 openpyxl 保存。 另外，默认的保存方式得到的 Excel 表格是带有 index （可以简单理解为原始数据的行号，不过是以 0 开头）和 header （列标），如果不需要它，那么再后面加上参数 index=None 和 header=None 即可； 保存的默认标签页是 Sheet1，可以使用 sheet_name，参数来指定标签页名称。 fd.to_excel(&#39;Workbook_copy.xlsx, sheet_name=&quot;foo&quot;, index=None, header=None&#39;) 选取单元格内容使用 loc 和 iloc 方法， 他们之间的区别是 loc 是基于标签， iloc 基于索引。 读取一行 fd.loc(1, :) 读取一列 fd[&#39;列标签1&#39;] # 通常的做法 fd.loc(:, [&#39;列标签1&#39;]) # 还可以这么做 读取一行一列 fd.loc[3,[&#39;列标签1&#39;]] # or fd.iloc[3, 0] 读取多行多列 fd.loc[[1, 3, 5], [&#39;列标签1&#39;, &#39;列标签2&#39;]] # or fd.iloc[[1, 3, 5], [0, 1]] 读取某列所有元素vals = fd.loc(&#39;列标签&#39;).to_list() 连接将 A 列的值和 B 列 的值连接起来： fd[&#39;A&#39;].map(str) + fd[&#39;B&#39;].map(str) 筛选比如我们的表格中有一列的索引名称为“是否安装”，想选取值为 N 的数据： data_y = data[data[&#39;是否安装&#39;] == &#39;N&#39;] 使用 &amp; 和 | 可以使用更多的筛选条件，比如： data_y = data[(data[&#39;是否安装&#39;] == &#39;Y&#39;) &amp; (data[&#39;用途&#39;] == &#39;效率&#39;)] 对于更复杂的筛选条件，使用 apply ，先用简单的例子来说明一下，比如还是上文的选取索引值名称为“是否安装”里面 N 的数据，如果要用 apply 方法实现的话： def IsInstalled(val): return val == &#39;N data_y = data[data[&#39;是否安装&#39;].apply(IsInstalled)] apply 可以带有参数，更为灵活 def IsInstalledArgs(val, is_install): return val == is_install data_y = data[data[&#39;是否安装&#39;].apply(IsInstalledArgs, args=(&#39;N&#39;,))] 统计df.shape # 返回数据的行列 df.count # 返回每一列中非空值的个数 len(df[&#39;Column&#39;].index.values) # 数据的条数 修改df.loc[3, &#39;列标签&#39;] = &#39;一个新值&#39; Pandas 还有很多方法，但以上方法对于我目前日常处理 Excel 数据的操作是够用的了，后面遇到了再补充吧。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Pandas","slug":"Pandas","permalink":"http://yoursite.com/tags/Pandas/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-03-20T17:19:56.000Z","updated":"2020-03-23T16:16:01.334Z","comments":true,"path":"2020/03/21/hello-world/","link":"","permalink":"http://yoursite.com/2020/03/21/hello-world/","excerpt":"","text":"你好，这是我的第一篇个人博客，主要记录一些软件工程，编码的心得，还有相关工具使用方法。 #include &lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; &quot;Hello,world!&quot; &lt;&lt; endl; return 0; }","categories":[],"tags":[{"name":"misc","slug":"misc","permalink":"http://yoursite.com/tags/misc/"}]}],"categories":[],"tags":[{"name":"Misc","slug":"Misc","permalink":"http://yoursite.com/tags/Misc/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Regex","slug":"Regex","permalink":"http://yoursite.com/tags/Regex/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Tool","slug":"Tool","permalink":"http://yoursite.com/tags/Tool/"},{"name":"Pandas","slug":"Pandas","permalink":"http://yoursite.com/tags/Pandas/"},{"name":"misc","slug":"misc","permalink":"http://yoursite.com/tags/misc/"}]}